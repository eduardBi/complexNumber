<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="./Complex.js/complex.js"></script>
    <script>
        
        let dataInput={
            firstBranch:{
                coil:25,
                resistance:15,
                condens:125,
                isStraight:true
            },
            secondBranch:{
                resistance:12,
                coil:80,
                isStraight:false
            },
            thirdbranch:{
                resistance:8,
                isStraight:false 
            }
            
        }
        let frequency=50
        let psy=180/4
        let startVoltage=50*Math.sqrt(2)

            function reactiveResist (dataInput){
                let reactiveResictance=[]
                let arrayOfKeys=Object.keys(dataInput);

                for(let i=0;i<arrayOfKeys.length;i++){

                    
                    
                    if(dataInput[arrayOfKeys[i]].coil && dataInput[arrayOfKeys[i]].condens){
                              reactiveResictance.push({...dataInput[arrayOfKeys[i]],
                                reactiveResistenceOfCoil:2*Math.PI*frequency*dataInput[arrayOfKeys[i]].coil*10**-3,
                                reactiveResistenceOfCondense:1/(Math.PI*frequency*2*dataInput[arrayOfKeys[i]].condens*10**-6*-1),
                            })
                              
                        
                        }else   if(dataInput[arrayOfKeys[i]].coil && !dataInput[arrayOfKeys[i]].condens)
                        {
                            
                            reactiveResictance.push({...dataInput[arrayOfKeys[i]],
                                reactiveResistenceOfCoil:2*Math.PI*frequency*dataInput[arrayOfKeys[i]].coil*10**-3,
                                
                            })
                    
                        
                }else   if(!dataInput[arrayOfKeys[i]].coil && dataInput[arrayOfKeys[i]].condens){
                            
                            
                    reactiveResictance.push({...dataInput[arrayOfKeys[i]],
                                reactiveResistenceOfCondense:1/(Math.PI*frequency*2*dataInput[arrayOfKeys[i]].condens*10**-6*-1),
                            })
                        
                }else {
                    reactiveResictance.push({...dataInput[arrayOfKeys[i]]})            

                }
            
        }
        
            return reactiveResictance
            
}
            let outputOfReactiveResiters= reactiveResist(dataInput)
        
        function fullResistenceOfBranch(dataWithReactiveResictence){
                let putchedBranchesResist=[];
                
                
                for (let i = 0; i < dataWithReactiveResictence.length; i++) {
        
                let currentFullResistence=Complex(0,0);  
                    
                dataWithReactiveResictence[i].hasOwnProperty('reactiveResistenceOfCondense') ? currentFullResistence=currentFullResistence.add(0,dataWithReactiveResictence[i].reactiveResistenceOfCondense):''


                dataWithReactiveResictence[i].hasOwnProperty('reactiveResistenceOfCoil') ? currentFullResistence=currentFullResistence.add(0,dataWithReactiveResictence[i].reactiveResistenceOfCoil):''

                dataWithReactiveResictence[i].hasOwnProperty('resistance') ? currentFullResistence=currentFullResistence.add(dataWithReactiveResictence[i].resistance,0):''

                putchedBranchesResist.push(
                                {...dataWithReactiveResictence[i],
                                    fullResistenceOfBranch:currentFullResistence
                                }
                )
                        
                    
                }
                
                console.log(putchedBranchesResist)
                return putchedBranchesResist
        }
        let putchedBranchedsResictence=fullResistenceOfBranch(outputOfReactiveResiters);
        //повторяется с низу 
        function resictenceOfChain(fullResistenceOfBranch){
            
            let arrayOfParralel=[];
            let sumOfStraight=Complex(0,0);
            let sumOfParralel=Complex(0,0);
            
            for (let i = 0; i < fullResistenceOfBranch.length; i++) {
                 fullResistenceOfBranch[i].fullResistenceOfBranch
                 

                if(fullResistenceOfBranch[i].isStraight){
                    sumOfStraight=sumOfStraight.add(fullResistenceOfBranch[i].fullResistenceOfBranch)
                    console.log(sumOfStraight)
                 }else{
                    arrayOfParralel.push(fullResistenceOfBranch[i].fullResistenceOfBranch)
                 }
                
            }
            if(arrayOfParralel.length==2){
                sumOfParralel=(Complex(arrayOfParralel[0]).mul(arrayOfParralel[1])).div(Complex(arrayOfParralel[0]).add(arrayOfParralel[1]))
                
                
            }else{

            }
            
            return sumOfStraight.add(sumOfParralel)


        }
        let fullResictance=resictenceOfChain(putchedBranchedsResictence)
        

        function fullVoltage(startVoltage,angle){
            let complexVoltageString=startVoltage/Math.sqrt(2)+'e^'+angle
            let complexVoltageValue=startVoltage/Math.sqrt(2)

            let bSide=complexVoltageValue*Math.cos(angle/57.29)
            let aSide=complexVoltageValue*Math.sin(angle/57.29)

            console.log(Complex(bSide,aSide))
            return Complex(bSide,aSide)


        }
        let fullVolatgeInchain=fullVoltage(startVoltage,psy)


        function currentInAllBranches(fullVolatgeInchain,fullResictance){
            console.log(fullVolatgeInchain)
            console.log(fullResictance)

            return fullVolatgeInchain.div(fullResictance)

        }
        let fullCurrentInChain=currentInAllBranches(fullVolatgeInchain,fullResictance)
        
        function VoltageInBranches(fullCurrentInChain,putchedBranchedsResictence){
            let switchFlag=0;
            let voltageOnEachBranch=[];
            let parralelResistance=Complex(0,0);
            let arrayOfParralel=[];
            console.log(fullCurrentInChain)
            for (let i = 0; i < putchedBranchedsResictence.length; i++) {
                
                if(putchedBranchedsResictence[i].isStraight && switchFlag==0 ){
                    voltageOnEachBranch.push(putchedBranchedsResictence[i].fullResistenceOfBranch.mul(fullCurrentInChain))
                    console.log(1)
                }else if((putchedBranchedsResictence[i].isStraight && switchFlag==1) )
                {
                    console.log(2)
                    parralelResistance=(Complex(arrayOfParralel[0]).mul(arrayOfParralel[1])).div(Complex(arrayOfParralel[0]).add(arrayOfParralel[1]))
                    
                    voltageOnEachBranch.push(parralelResistance.mul(fullCurrentInChain))
                    console.log(fullCurrentInChain)
                    voltageOnEachBranch.push(parralelResistance.mul(fullCurrentInChain))
                    //double push handels voltage on two branches with same index branch-voltage

                    voltageOnEachBranch.push(putchedBranchedsResictence[i].fullResistenceOfBranch.mul(fullCurrentInChain))
                    // handels if last one isn't parralel

                    switchFlag=0
                }else if(!putchedBranchedsResictence[i].isStraight &&putchedBranchedsResictence.length==i+1 ){
                    console.log(3)
                    switchFlag=1
                    arrayOfParralel.push(putchedBranchedsResictence[i].fullResistenceOfBranch)

                    parralelResistance=(Complex(arrayOfParralel[0]).mul(arrayOfParralel[1])).div(Complex(arrayOfParralel[0]).add(arrayOfParralel[1]))
                    voltageOnEachBranch.push(parralelResistance.mul(fullCurrentInChain))
                    voltageOnEachBranch.push(parralelResistance.mul(fullCurrentInChain))
                    //double push handels voltage on two branches with same index branch-voltage
                }else{
                    console.log(4)
                    switchFlag=1
                    arrayOfParralel.push(putchedBranchedsResictence[i].fullResistenceOfBranch)
                }
                // код повторяется нужно сделать функцию которая возвращаеттолько сопротивление для каждого соединения ветвей paralleresistance=[], может считать только сопративление двух ветвей                 
                
                
            }
            return voltageOnEachBranch

        }
        let voltageOnEachBranch= VoltageInBranches(fullCurrentInChain,putchedBranchedsResictence);
        console.log(voltageOnEachBranch)

        function currentOnEachBranshes(fullCurrentInChain,voltageOnEachBranch,putchedBranchedsResictence){
            //просчитываем так на всех ветвях кроме первого
                let arrayOfCurrents=[fullCurrentInChain]
                for (let i = 1; i < voltageOnEachBranch.length; i++) {
                    
                    arrayOfCurrents.push(voltageOnEachBranch[i].div(putchedBranchedsResictence[i].fullResistenceOfBranch))
                }
                return arrayOfCurrents;

        }
        let AllCurrents=currentOnEachBranshes(fullCurrentInChain,voltageOnEachBranch,putchedBranchedsResictence);
        
        function VoltageOnEachElemet (AllCurrents,dataInput){

            let arrayOfKeys=Object.keys(dataInput)
            let resistanceOnEachelement=[]
            for(let i=0;i<arrayOfKeys.length;i++){


                if(dataInput[arrayOfKeys[i]].coil){

                    resistanceOnEachelement.push({name:`Coil${i+1}`,voltageonCoil:AllCurrents[i].mul(Complex(0,2*Math.PI*frequency*dataInput[arrayOfKeys[i]].coil*10**-3))})

                }
                if(dataInput[arrayOfKeys[i]].condens){

                    resistanceOnEachelement.push({name:`condense${i+1}`,voltageonCondense:AllCurrents[i].mul(0,Complex(1/(Math.PI*frequency*2*dataInput[arrayOfKeys[i]].condens*10**-6*-1)))})

                }
                if(dataInput[arrayOfKeys[i]].resistance){

                    resistanceOnEachelement.push({name:`resist${i+1}`,voltageonResist:AllCurrents[i].mul(Complex(dataInput[arrayOfKeys[i]].resistance,0))})

                }

            }

            console.log(resistanceOnEachelement)
            return resistanceOnEachelement

        }
        VoltageOnEachElemet(AllCurrents,dataInput)


        function momentumCurrent(AllCurrents){
            console.log(AllCurrents)
            console.log(AllCurrents)
            
        }
        

        /*
        function signToComplex(length,angle){
            let hipotinize=Math.asin(angle/57.29)
            let bSide=length*Math.cos(angle/57.29)
            let aSide=length*Math.sin(angle/57.29)
            console.log(bSide)
            console.log(aSide)
        }
        signToComplex(1.86,81.8)



        function putchToSignFormula(signPutcher){
            
            let forAsinFunc=signPutcher['im']/(Math.sqrt(signPutcher['re']**2+signPutcher['im']**2))
        console.log(Math.asin(forAsinFunc)*57.29)
        }
        
        putchToSignFormula(Complex(6.76,1.56))

        */
        
    </script>
</body>
</html>