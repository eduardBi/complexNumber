<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body{
            font-size: 16px;
        }
     span{
        font-size: 12px;
        text-align: end;
        
    }
    div>div{
        
    display: flex;        
    flex-direction: column;
    }
    hr{
        margin:  0 10px;
        border: 2px solid black;
        min-width: 100px;
        background: black;
    }
    div{
        margin:  10px 0;
        display: flex;
        align-items: center;
    }
    
    </style>
</head>
<body>
    <script src="./Complex.js/complex.js"></script>
    <script>
        let myWar=document.body
        myWar.innerHTML=myWar.innerHTML+'<h1>world</h1>'
        
        let dataInput={
            firstElement:{
                  type:'condens',
                  value:150,
                  startIndex:3,
                  endIndex:3
            },fourth:{
                  type:'condens',
                  value:150,
                  startIndex:3,
                  endIndex:3
            },
            secondElement:{
                type:'coil',
                value:25,
                startIndex:2,
                endIndex:2
            }
            ,
            fourthElement:{
                type:'resist',
                value:70,
                startIndex:4,
                endIndex:7
            },
            fifth:{
                type:'resist',
                value:70,
                startIndex:4,
                endIndex:7
            },
            sixth:{
                type:'resist',
                value:70,
                startIndex:4,
                endIndex:7
            },
            eight:{
                type:'resist',
                value:70,
                startIndex:7,
                endIndex:9
            },nine:{
                type:'resist',
                value:70,
                startIndex:7,
                endIndex:9
            },zix:{
                type:'resist',
                value:70,
                startIndex:7,
                endIndex:10
            }
            

        }
        let frequency=50
        let psy=180/3
        let startVoltage=100*Math.sqrt(2)


     

            function reactiveResist (dataInput){
                let reactiveResictance=[]
                let arrayOfKeys=Object.keys(dataInput);

                for(let i=0;i<arrayOfKeys.length;i++){

                    
                if(dataInput[arrayOfKeys[i]].type=='coil')
                        {   
                            reactiveResictance.push({...dataInput[arrayOfKeys[i]],
                                reactiveResistence:Complex(0,2*Math.PI*frequency*dataInput[arrayOfKeys[i]].value*10**-3),
                                
                            })                    
                }else   if(dataInput[arrayOfKeys[i]].type=='condens'){
                            
                    reactiveResictance.push({...dataInput[arrayOfKeys[i]],
                                reactiveResistence:Complex(0,1/(Math.PI*frequency*2*dataInput[arrayOfKeys[i]].value*10**-6*-1)),
                            })
                }else if(dataInput[arrayOfKeys[i]].type=='resist'){
                    reactiveResictance.push({...dataInput[arrayOfKeys[i]],reactiveResistence:Complex(dataInput[arrayOfKeys[i]].value,0)})            

                }else{

                }
            
        }
        console.log(reactiveResictance)
        
            return reactiveResictance
            
}
let outputOfReactiveResiters= reactiveResist(dataInput)
        
        function formBranches(dataWithReactiveResictence){
        //добавить сортировку от меньшего к большему        
            let switchNumber=0;
            let newBranches=[]
            newBranches[switchNumber]={number:switchNumber,data:[]}

            for (let i = 0; i < dataWithReactiveResictence.length; i++) {
       
                if(dataWithReactiveResictence[i].startIndex!=dataWithReactiveResictence[i].endIndex){
                //если парралельное соединение 
                        
                let beginingNumber=newBranches[switchNumber].data.filter(e=>e.startIndex==dataWithReactiveResictence[i].startIndex)

                let  endingNumber=newBranches[switchNumber].data.filter(e=>e.endIndex==dataWithReactiveResictence[i].endIndex)        

                   //проверяю с одной ли парралельной ветви        
                if(beginingNumber.startIndex===endingNumber.startIndex && beginingNumber.endIndex===endingNumber.endIndex && beginingNumber.length!=0 && endingNumber.length!=0){

                    newBranches[switchNumber].data.push(dataWithReactiveResictence[i])
                    
                }else {
                       switchNumber+=1;
                        newBranches[switchNumber]={number:switchNumber,data:[]}
                        newBranches[switchNumber].data.push(dataWithReactiveResictence[i])
                
                }
                }else{
                    // последовательный элемент всегда заносится до первого парралельного соединения 
                    newBranches[switchNumber].data.push(dataWithReactiveResictence[i])
                    
                }
                
            }
            
            console.log(newBranches)
            return newBranches
        }
        let putchedBranchedsResictence=formBranches(outputOfReactiveResiters);

        
        function resictenceOfChain(fullResistenceOfBranch){
            console.log(fullResistenceOfBranch)
            let arrayOfParralel=[];
            let fullChainResistance=Complex(0,0)

            for (let i = 0; i < fullResistenceOfBranch.length; i++) {
                let complexResistanceOfBranch=Complex(0,0)
                for (let j = 0; j < fullResistenceOfBranch[i].data.length; j++) {
                        
                    complexResistanceOfBranch=complexResistanceOfBranch.add(fullResistenceOfBranch[i].data[j].reactiveResistence)
                    
                }

                fullResistenceOfBranch[i].branchresistance=complexResistanceOfBranch
                //branchResistance
                fullChainResistance=fullChainResistance.add(complexResistanceOfBranch)
                //full resistance
            }            

            return {fullChainResistance,branchData:fullResistenceOfBranch}

        }
        let fullResictance=resictenceOfChain(putchedBranchedsResictence)
         

        function fullVoltage(startVoltage,angle,object){
            let complexVoltageString=startVoltage/Math.sqrt(2)+'e^'+angle
            let complexVoltageValue=startVoltage/Math.sqrt(2)

            let bSide=complexVoltageValue*Math.cos(angle/57.29)
            let aSide=complexVoltageValue*Math.sin(angle/57.29)

            return {...fullResictance,fullVoltage:Complex(bSide,aSide)}

        }


        let fullVolatgeInchain=fullVoltage(startVoltage,psy,fullResictance)
        

        function currentInAllBranches(object){

            return {...object,CurrentInAllBranches:object.fullVoltage.div(object.fullChainResistance)}

        }
        let fullCurrentInChain=currentInAllBranches(fullVolatgeInchain)
        console.log(fullCurrentInChain)
        
        function VoltageInBranches(object){   
            
            return voltageOnEachBranch

        }

        
        let voltageOnEachBranch= VoltageInBranches(fullCurrentInChain,putchedBranchedsResictence);
        

        function currentOnEachBranshes(fullCurrentInChain,voltageOnEachBranch,putchedBranchedsResictence){
            //просчитываем так на всех ветвях кроме первого
                let arrayOfCurrents=[fullCurrentInChain]
                console.log(`ток по всей цепи ${arrayOfCurrents[0]} angle=${putchToSignFormula(arrayOfCurrents[0]).angle} langth=${putchToSignFormula(arrayOfCurrents[0]).length} `)
                for (let i = 1; i < voltageOnEachBranch.length; i++) {
                    
                    arrayOfCurrents.push(voltageOnEachBranch[i].div(putchedBranchedsResictence[i].fullResistenceOfBranch))
                    console.log(`ток номер ${i+1} ${arrayOfCurrents[i]} angle=${putchToSignFormula(arrayOfCurrents[i]).angle} langth=${putchToSignFormula(arrayOfCurrents[i]).length} `)
                }
                
                return arrayOfCurrents;

        }
        let AllCurrents=currentOnEachBranshes(fullCurrentInChain,voltageOnEachBranch,putchedBranchedsResictence);
        
        function VoltageOnEachElemet (AllCurrents,dataInput){

            let arrayOfKeys=Object.keys(dataInput)
            let resistanceOnEachelement=[]
            for(let i=0;i<arrayOfKeys.length;i++){


                if(dataInput[arrayOfKeys[i]].coil){

                    resistanceOnEachelement.push({name:`Coil${i+1}`,voltageonElemen:AllCurrents[i].mul(Complex(0,2*Math.PI*frequency*dataInput[arrayOfKeys[i]].coil*10**-3))})
                    

                }
                if(dataInput[arrayOfKeys[i]].condens){

                    resistanceOnEachelement.push({name:`condense${i+1}`,voltageonElemen:AllCurrents[i].mul(0,Complex(1/(Math.PI*frequency*2*dataInput[arrayOfKeys[i]].condens*10**-6*-1)))})

                }
                if(dataInput[arrayOfKeys[i]].resistance){

                    resistanceOnEachelement.push({name:`resist${i+1}`,voltageonElemen:AllCurrents[i].mul(Complex(dataInput[arrayOfKeys[i]].resistance,0))})

                }
                

            }
            console.log(`напряжения на элементах снизу`)
            console.log(resistanceOnEachelement)
            
            return resistanceOnEachelement

        }
        let eachVoltage=VoltageOnEachElemet(AllCurrents,dataInput)


        function momentumCurrent(AllCurrents){
            let momentumCurrents=[];

            console.log(momentumCurrents)
            for (let i = 0; i < AllCurrents.length; i++) {
                let angleAndLength=putchToSignFormula(AllCurrents[i])
                momentumCurrents.push((angleAndLength.length*Math.sqrt(2)).toFixed(2)+'*sin(' +(2*Math.PI*frequency).toFixed(2)+'t+'+angleAndLength.angle.toFixed(2)+')')

            }
            console.log('моментальные токи снизу')
            console.log(momentumCurrents)
            return momentumCurrents

            
        }
        
        let momentumCurrentArray= momentumCurrent(AllCurrents)

        function momentumVoltageOneachBranch(startVoltage,voltageOnEachBranch){

            let momentumVoltage=[]
            
            momentumVoltage.push((Math.sqrt(2)*Math.sqrt(startVoltage.re**2+startVoltage.im**2)).toFixed(2)+'*(sin'+(2*Math.PI*frequency).toFixed(2)+'t+'+psy+')')


            for (let i = 0; i < voltageOnEachBranch.length; i++) {
                
                let angleAndLength=putchToSignFormula(voltageOnEachBranch[i])
                momentumVoltage.push((angleAndLength.length*Math.sqrt(2)).
                toFixed(2)+'*sin(' +(2*Math.PI*frequency).toFixed(2)+'t+('
                +angleAndLength.angle.toFixed(2)+'))')
                

            }
            console.log('моментальные напряжения ветвей');
            console.log(momentumVoltage);

        }

        momentumVoltageOneachBranch(fullVolatgeInchain,voltageOnEachBranch)


        function momentumVoltageOneachElement(eachVoltage){
                    
                let MomentumVoltageOfEachElement=[];
                for (let i = 0; i < eachVoltage.length; i++) {
                    
                    let angleAndLength=putchToSignFormula(eachVoltage[i].voltageonElemen)
                    

                    MomentumVoltageOfEachElement.push({...eachVoltage[i],
                    momenumVoltage:(angleAndLength.length*Math.sqrt(2)).
                    toFixed(2)+'*sin(' +(2*Math.PI*frequency).toFixed(2)+'t+('
                    +angleAndLength.angle.toFixed(2)+'))'   
                    })
                    
                    
                }

                    return  MomentumVoltageOfEachElement;
        }
        console.log('моментальные напряжения');
        console.log(momentumVoltageOneachElement(eachVoltage))




        function CheckIsRight(AllCurrents) {
                
            let number=0;
            
            for (let i = 0; i < AllCurrents.length; i++) {
                let angleAndLength=putchToSignFormula(AllCurrents[i])
                if(i==0){
                
                number+=angleAndLength.length*Math.sin(angleAndLength.angle/57.29)}else{
                number-=angleAndLength.length*Math.sin(angleAndLength.angle/57.29)
                }
                
            }

            if(number<0.5){
                return true
            }else{
                return false
            }


        }
        function graphTable(fullCurrentInChain){

            console.log(fullCurrentInChain)
            let squeared=Math.sqrt(2)*putchToSignFormula(fullCurrentInChain).length
            let angle=putchToSignFormula(fullCurrentInChain).angle/57.29
            let division=1/frequency
            
            let CurrentValuseOnGraph=[]
            for (let i = 0; i <= division+division*1/10; i=i+division/10) {
                CurrentValuseOnGraph.push(
                    {   
                        timeValue:i,
                        value:squeared*Math.sin(angle+314*i)
                    }
                )

                
            }
            console.log('значение графика токов')
            return CurrentValuseOnGraph   

        }

        let currentgraphTable=graphTable(fullCurrentInChain);
        let voltageTable=graphTable(fullVolatgeInchain);
        console.log(getPower(currentgraphTable, voltageTable))


        function getPower(toks, voltage){
            endArray=[];
            for (let i = 0; i < toks.length; i++) {

                endArray.push(toks[i].value*voltage[i].value);
                
            }
            return endArray
        }

    
        function signToComplex(length,angle){
            let hipotinize=Math.asin(angle/57.29)
            let bSide=length*Math.cos(angle/57.29)
            let aSide=length*Math.sin(angle/57.29)
            console.log(bSide)
            console.log(aSide)
        }
        

        function putchToSignFormula(signPutcher){
            
            let forAsinFunc=signPutcher['im']/(Math.sqrt(signPutcher['re']**2+signPutcher['im']**2))
            let angleF=0;

            if(signPutcher['re']>0){
                angleF=Math.asin(forAsinFunc)*57.29
            }else{ 
                angleF=180-Math.asin(forAsinFunc)*57.29
            }
            return {
                angle:angleF,
                length:Math.sqrt(signPutcher['re']**2+signPutcher['im']**2)
            }
        }
        
        

        
        
    </script>
</body>
</html>