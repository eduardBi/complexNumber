<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body{
            font-size: 16px;
        }
     span{
        font-size: 12px;
        text-align: end;
        
    }
    div>div{
        
    display: flex;        
    flex-direction: column;
    }
    hr{
        margin:  0 10px;
        border: 2px solid black;
        min-width: 100px;
        background: black;
    }
    div{
        margin:  10px 0;
        display: flex;
        align-items: center;
    }
    
    </style>
</head>
<body>
    <script src="./Complex.js/complex.js"></script>
    <script>
        let myWar=document.body
        myWar.innerHTML=myWar.innerHTML+'<h1>world</h1>'
        
        let dataInput={
            firstElement:{
                  type:'condens',
                  value:150,
                  startIndex:3,
                  endIndex:3
            },fourth:{
                  type:'condens',
                  value:150,
                  startIndex:3,
                  endIndex:3
            },
            secondElement:{
                type:'coil',
                value:25,
                startIndex:2,
                endIndex:2
            }
            ,
            fourthElement:{
                type:'resist',
                value:70,
                startIndex:4,
                endIndex:7
            },
            fifth:{
                type:'resist',
                value:70,
                startIndex:4,
                endIndex:7
            },
            sixth:{
                type:'resist',
                value:70,
                startIndex:4,
                endIndex:7
            },
            eight:{
                type:'resist',
                value:70,
                startIndex:7,
                endIndex:9
            },nine:{
                type:'resist',
                value:70,
                startIndex:7,
                endIndex:9
            },zix:{
                type:'resist',
                value:70,
                startIndex:7,
                endIndex:10
            }
            

        }


        let knots=[
            {
                id:1
            },
            {
                id:2
            },
            {
                id:3
            },{
                id:4
            },{
                id:5
            }
        ]

        let branches=[
        {
            startKnot:2,
            endKnot:4
        },
        {
            startKnot:1,
            endKnot:2
        },
        {
            startKnot:1,
            endKnot:2
        }
        ,
        {
            startKnot:2,
            endKnot:3
        },
        {
            startKnot:1,
            endKnot:3
        },              {
            startKnot:1,
            endKnot:3
        },{
            startKnot:3,
            endKnot:4
        },{
            startKnot:1,
            endKnot:4
        }                
        
        
        ]

        function returnBranches(knots,elements){
            // need to be splited into different functions
            let reapeatedKnots=0;
            let brancharray=[];
            let pushinNumber=0;
            
            
            


            
            for (let i = 0; i < knots.length; i++) {

                
                for (let j = 0; j < knots.length-reapeatedKnots; j++) {

                    

                    if(knots[reapeatedKnots].id!=knots[j+reapeatedKnots].id){
                        //knots cant be equal bacause they dont create a branch
                       console.log(knots[reapeatedKnots])
                       console.log(knots[j+reapeatedKnots])
                            for (let f = 0; f < elements.length; f++) {
                                // need to be sorted and can delete element after pushing to array
                                console.log(elements[f])
                                console.log('есть ли уже  ветвь с этим элементом')
                                let alredyInBrenchArray= brancharray.filter(e=>{ 
                                return e.branchStart==elements[f].startKnot && e.branchEnd==elements[f].endKnot
                                    
                            })
                                

                                if(elements[f].startKnot==knots[reapeatedKnots].id && elements[f].endKnot==knots[j+reapeatedKnots].id && alredyInBrenchArray.length!=0){
                                    //уже есть ветвь с этим элементом 
                                    
                                    brancharray[pushinNumber-1].data.push(elements[f])

                                }else  if(elements[f].startKnot==knots[reapeatedKnots].id && elements[f].endKnot==knots[j+reapeatedKnots].id && alredyInBrenchArray.length==0){
                                    //ещё нет 
                                    
                                    brancharray.push({branchStart:elements[f].startKnot,branchEnd:elements[f].endKnot,data:[]})
                                    brancharray[pushinNumber].data.push(elements[f])
                                    pushinNumber++;
                                    
                                }
                                
                            }

                    }
                }   
                reapeatedKnots++ 
                //last knot will never be executed because it isntt connected to anything            
                

            }
            
            return brancharray
                        
        }
        let branchesArray=returnBranches(knots,branches);

        function createLines(branchesArray){
            let lines=[];
            let arrayOfKeys=Object.keys(branchesArray);
            let newLine=0
            console.log(branchesArray)
            for (let i = 0; i < arrayOfKeys.length; i++) {
                console.log(branchesArray[arrayOfKeys[i]])
                let some=branchesArray.filter(e=>e.branchStart==branchesArray[arrayOfKeys[i]].branchEnd)
                console.log(some)

                    
                
                }

                
            

        }

        createLines(branchesArray)

        

        let frequency=50
        let psy=180/3
        let startVoltage=100*Math.sqrt(2)


     

            function reactiveResist (dataInput){
                let reactiveResictance=[]
                let arrayOfKeys=Object.keys(dataInput);

                for(let i=0;i<arrayOfKeys.length;i++){

                    
                if(dataInput[arrayOfKeys[i]].type=='coil')
                        {   
                            reactiveResictance.push({...dataInput[arrayOfKeys[i]],
                                reactiveResistence:Complex(0,2*Math.PI*frequency*dataInput[arrayOfKeys[i]].value*10**-3),
                                
                            })                    
                }else   if(dataInput[arrayOfKeys[i]].type=='condens'){
                            
                    reactiveResictance.push({...dataInput[arrayOfKeys[i]],
                                reactiveResistence:Complex(0,1/(Math.PI*frequency*2*dataInput[arrayOfKeys[i]].value*10**-6*-1)),
                            })
                }else if(dataInput[arrayOfKeys[i]].type=='resist'){
                    reactiveResictance.push({...dataInput[arrayOfKeys[i]],reactiveResistence:Complex(dataInput[arrayOfKeys[i]].value,0)})            

                }else{

                }
            
        }
        console.log(reactiveResictance)
        
            return reactiveResictance
            
}
let outputOfReactiveResiters= reactiveResist(dataInput)
        
        function formBranches(dataWithReactiveResictence){
        //добавить сортировку от меньшего к большему        
            let switchNumber=0;
            let newBranches=[]
            newBranches[switchNumber]={number:switchNumber,data:[]}

            for (let i = 0; i < dataWithReactiveResictence.length; i++) {
       
                if(dataWithReactiveResictence[i].startIndex!=dataWithReactiveResictence[i].endIndex){
                //если парралельное соединение 
                        
                let beginingNumber=newBranches[switchNumber].data.filter(e=>e.startIndex==dataWithReactiveResictence[i].startIndex)

                let  endingNumber=newBranches[switchNumber].data.filter(e=>e.endIndex==dataWithReactiveResictence[i].endIndex)        

                   //проверяю с одной ли парралельной ветви        
                if(beginingNumber.startIndex===endingNumber.startIndex && beginingNumber.endIndex===endingNumber.endIndex && beginingNumber.length!=0 && endingNumber.length!=0){

                    newBranches[switchNumber].data.push(dataWithReactiveResictence[i])
                    
                }else {
                       switchNumber+=1;
                        newBranches[switchNumber]={number:switchNumber,data:[]}
                        newBranches[switchNumber].data.push(dataWithReactiveResictence[i])
                
                }
                }else{
                    // последовательный элемент всегда заносится до первого парралельного соединения 
                    newBranches[switchNumber].data.push(dataWithReactiveResictence[i])
                    
                }
                
            }
            
            console.log(newBranches)
            return newBranches
        }
        let putchedBranchedsResictence=formBranches(outputOfReactiveResiters);

        
        function resictenceOfChain(fullResistenceOfBranch){
            console.log(fullResistenceOfBranch)
            let arrayOfParralel=[];
            let fullChainResistance=Complex(0,0)

            for (let i = 0; i < fullResistenceOfBranch.length; i++) {
                let complexResistanceOfBranch=Complex(0,0)
                for (let j = 0; j < fullResistenceOfBranch[i].data.length; j++) {
                        
                    complexResistanceOfBranch=complexResistanceOfBranch.add(fullResistenceOfBranch[i].data[j].reactiveResistence)
                    
                }

                fullResistenceOfBranch[i].branchresistance=complexResistanceOfBranch
                //branchResistance
                fullChainResistance=fullChainResistance.add(complexResistanceOfBranch)
                //full resistance
            }            

            return {fullChainResistance,branchData:fullResistenceOfBranch}

        }
        let fullResictance=resictenceOfChain(putchedBranchedsResictence)
         

        function fullVoltage(startVoltage,angle,object){
            let complexVoltageString=startVoltage/Math.sqrt(2)+'e^'+angle
            let complexVoltageValue=startVoltage/Math.sqrt(2)

            let bSide=complexVoltageValue*Math.cos(angle/57.29)
            let aSide=complexVoltageValue*Math.sin(angle/57.29)

            return {...fullResictance,fullVoltage:Complex(bSide,aSide)}

        }


        let fullVolatgeInchain=fullVoltage(startVoltage,psy,fullResictance)
        

        function currentInAllBranches(object){

            return {...object,CurrentInAllBranches:object.fullVoltage.div(object.fullChainResistance)}

        }
        let fullCurrentInChain=currentInAllBranches(fullVolatgeInchain)

        

        function VoltageInBranches(object){   

            
                for (let i = 0; i < object.branchData.length; i++) {
                    
                    object.branchData[i].voltageOnBranch=object.branchData[i].branchresistance.mul(object.CurrentInAllBranches)
                    
                }

            return object

        }

        
        let voltageOnEachBranch= VoltageInBranches(fullCurrentInChain);
        
        

        function currentOnEachBranshes(object){
            
            //просчитываем так на всех ветвях кроме первого
                for (let i = 0; i < object.branchData.length; i++) {

                    object.branchData[i].currentInChain=object.branchData[i].voltageOnBranch.div(object.branchData[i].branchresistance)
                
                }

                return object;

        }
        let AllCurrents=currentOnEachBranshes(voltageOnEachBranch);
        

        function VoltageOnEachElemet(object){

            console.log(object.branchData[1].data[0])

            for(let i=0; i < object.branchData.length;i++){
                
                for (let j = 0; j < object.branchData[i].data.length; j++) {
                    
                    object.branchData[i].data[j].voltageonElemen=object.branchData[i].data[j].reactiveResistence.mul(object.branchData[i].currentInChain)
                    
                }

            }

            return object

        }
        
        let eachVoltage=VoltageOnEachElemet(AllCurrents)


        function momentumCurrentAndVoltage(object){
            console.log(object)
            for (let i = 0; i < object.branchData.length; i++) {
                
                object.branchData[i].momentumCurren=returnSinValue(object.branchData[i].currentInChain)
                object.branchData[i].momentumVoltage=returnSinValue(object.branchData[i].voltageOnBranch)

            }
            
            return object

        }
        
        let momentumCurrentArray= momentumCurrent(eachVoltage)


        function momentumVoltageOneachElement(eachVoltage){
                    
                let MomentumVoltageOfEachElement=[];
                for (let i = 0; i < eachVoltage.length; i++) {
                    
                    let angleAndLength=putchToSignFormula(eachVoltage[i].voltageonElemen)
                    

                    MomentumVoltageOfEachElement.push({...eachVoltage[i],
                    momenumVoltage:(angleAndLength.length*Math.sqrt(2)).
                    toFixed(2)+'*sin(' +(2*Math.PI*frequency).toFixed(2)+'t+('
                    +angleAndLength.angle.toFixed(2)+'))'   
                    })
                    
                    
                }

                    return  MomentumVoltageOfEachElement;
        }
        console.log('моментальные напряжения');
        console.log(momentumVoltageOneachElement(eachVoltage))



        function graphTable(fullCurrentInChain){

            console.log(fullCurrentInChain)
            let squeared=Math.sqrt(2)*putchToSignFormula(fullCurrentInChain).length
            let angle=putchToSignFormula(fullCurrentInChain).angle/57.29
            let division=1/frequency
            
            let CurrentValuseOnGraph=[]
            for (let i = 0; i <= division+division*1/10; i=i+division/10) {
                CurrentValuseOnGraph.push(
                    {   
                        timeValue:i,
                        value:squeared*Math.sin(angle+314*i)
                    }
                )
                
            }
            console.log('значение графика токов')
            return CurrentValuseOnGraph   

        }

        let currentgraphTable=graphTable(fullCurrentInChain);
        let voltageTable=graphTable(fullVolatgeInchain);
        console.log(getPower(currentgraphTable, voltageTable))


        function getPower(toks, voltage){
            endArray=[];
            for (let i = 0; i < toks.length; i++) {

                endArray.push(toks[i].value*voltage[i].value);
                
            }
            return endArray
        }

        function returnSinValue(complexNumber){

            
            let angleAndLength=putchToSignFormula(complexNumber)
            
            return(angleAndLength.length*Math.sqrt(2)).
                    toFixed(2)+'*sin(' +(2*Math.PI*frequency).toFixed(2)+'t+('
                    +angleAndLength.angle.toFixed(2)+'))'   
                    

        }
        
        



        function putchToSignFormula(signPutcher){
            
            let forAsinFunc=signPutcher['im']/(Math.sqrt(signPutcher['re']**2+signPutcher['im']**2))
            let angleF=0;

            if(signPutcher['re']>0){
                angleF=Math.asin(forAsinFunc)*57.29
            }else{ 
                angleF=180-Math.asin(forAsinFunc)*57.29
            }
            return {
                angle:angleF,
                length:Math.sqrt(signPutcher['re']**2+signPutcher['im']**2)
            }
        }
        
        


       /* function signToComplex(length,angle){
            let hipotinize=Math.asin(angle/57.29)
            let bSide=length*Math.cos(angle/57.29)
            let aSide=length*Math.sin(angle/57.29)
            console.log(bSide)
            console.log(aSide)
        }*/
        
        
    </script>
</body>
</html>